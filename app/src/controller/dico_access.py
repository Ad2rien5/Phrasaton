import app.src.model.global_value as global_value
from app.src.model.dico import Dico
from app.src.model.global_value import GlobalValue


class DicoAccess:
    """
    This class serve as an intermediate to the model so the architecture use MVC design pattern.
    The use of this class will be improved with the addition of a save/load system.
    """

    def __init__(self):
        """
        Save the instance of the dico that will be used by the user
        """
        self.dico : Dico = Dico()

    def _purge_bad_char(self, word: str) -> str:
        """
        Remove all non-authorize char

        Parameter
        ---------
        word: str
            word to check

        Return
        ------
        word: str
            same word but without any non-authorize char
        """
        bad_char : list[str] = global_value.GlobalValue().BAD_CHAR
        for chara in bad_char:
            while chara in word:
                assert (
                        len(word) > 1
                ), f"CharacterError: a forbidden character have been found! PLease do not use '{word}' anymore."
                word = word.replace(chara, "")

        return word

    def _punctuation(self, word: str, punc: str) -> tuple[str, str]:
        """
        Separate the punctuation in a word

        Parameter
        ---------
        word: str
            word that contains a punctuation
        punc: str
            punctuation that need to be separated

        Return
        ------
        word: str
            word without punctuation

        punctuation: str
            the punctuation that was at the end of the word
        """
        assert (
                punc in word
        ), "This word doesn't contain the given punctuation."

        index: int = word.index(punc)
        return word[:index], word[index:]

    def _detection(self, word: str, nb_paren: int) -> tuple[int, str, str] | tuple[int, str, None]:
        """
        Assure that the word is correct and can be added to the database.
        In addition to the word, it can also return a punctuation

        Parameter
        ---------
        word: str
            word that need to be verified

        nb_paren: int
            number of opening parenthesis found

        Return
        ------
        nb_paren: int
            number of opening parenthesis found
        verified: str
            word cleansed of any unwanted character
        punctuation: ?str
            possible punctuation
        """
        verified : str = word
        gv : GlobalValue = global_value.GlobalValue()

        for start in gv.PARENTHESIS_START:
            nb_paren += verified.count(start)

        for end in gv.PARENTHESIS_END:
            nb_paren -= verified.count(end)

        for chara in gv.BAD_CHAR:
            if chara in verified:
                verified = self._purge_bad_char(verified)
                break

        for chara2 in gv.PUNCTUATION:
            if chara2 in verified:
                result : tuple[str, str] = self._punctuation(verified, chara2)
                return nb_paren, result[0], result[1]

        return nb_paren, verified, None

    def _mass_cleaning(self, text: str) -> list[str]:
        """
        Format a text for it to be ready to be saved in the database

        Parameter
        ---------
        text: str
            text that need to be formated

        Return
        ------
        formated: list<str>
            text cleanse and formatted in the format of a list of string
        """
        nb_parenthesis : int = 0

        text : list[str] = text.split(" ")
        formated : list[str] = []

        for word in text:
            test = self._detection(word, nb_parenthesis)
            nb_parenthesis = test[0]

            # the space is added to allow words to be separate when the bot will talk
            formated.append(" " + test[1])

            if test[2] is not None:
                formated.append(test[2])
        return formated

    def save_dico_data(self, command: str) -> str | None:
        """tuple
        Allow the model to learn from the user's command

        Parameters
        ----------
        command: str
            text send by the user

        Returns
        -------
        error: str?
            Error indication that have occurred during the process
            return "None" if no error occur
        """
        try:
            clean_text : tuple[str, ...] = tuple(self._mass_cleaning(command))
            self.dico.learn(clean_text)
        except AssertionError as err:
            return f"LearningError: {err}"
        return None

    def get_text_from_dico(self) -> tuple[str, None] | tuple[None, str]:
        """
        Get a generated text from the model

        Returns
        -------
        answer: str?
            text generated by the model
            return "None" if an error occur
        error: str?
            Error indication that have occurred during the process
            return "None" if no error occur
        """
        try:
            return self.dico.speak(), None
        except AssertionError as err:
            return None, f"SpeakingError: {err}"
